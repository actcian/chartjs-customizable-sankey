/*!
 * chartjs-chart-sankey v0.12.1
 * https://github.com/kurkle/chartjs-chart-sankey#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT license
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(require("chart.js"),require("chart.js/helpers")):"function"==typeof define&&define.amd?define(["chart.js","chart.js/helpers"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Chart,t.Chart.helpers)}(this,(function(t,e){"use strict";function o(t){return t&&-1!==["min","max"].indexOf(t)?t:"max"}const r=t=>void 0!==t;function n(t,e){const o=t.filter((t=>!e.has(t)));return o.length?o:t.slice(0,1)}const i=(t,e)=>t.x!==e.x?t.x-e.x:t.y-e.y;let s=-1;function a(t,e,o=function(){return s=s<100?s+1:0,s}()){let r=0;for(const n of t)n.node._visited!==o&&(n.node._visited=o,r+=n.node[e].length+a(n.node[e],e,o));return r}const l=t=>(e,o)=>a(e.node[t],t)-a(o.node[t],t)||e.node[t].length-o.node[t].length;function h(t,e){t.from.sort(l("from"));for(const o of t.from){const t=o.node;r(t.y)||(t.y=e,h(t,e)),e=Math.max(t.y+t.out,e)}return e}function c(t,e){t.to.sort(l("to"));for(const o of t.to){const t=o.node;r(t.y)||(t.y=e,c(t,e)),e=Math.max(t.y+t.in,e)}return e}function d(t,e){return r(t.y)?t.y:(t.y=e,e)}function f(t,e){t.sort(((t,e)=>Math.max(e.in,e.out)-Math.max(t.in,t.out)));const o=t[0];o.y=0;const n=h(o,0),i=c(o,0),s=function(t,e){const o=t.filter((t=>0===t.x)),n=t.filter((t=>t.x===e)),i=o.filter((t=>!r(t.y))),s=n.filter((t=>!r(t.y))),a=t.filter((t=>t.x>0&&t.x<e&&!r(t.y)));let l=o.reduce(((t,e)=>Math.max(t,e.y+e.out||0)),0),f=n.reduce(((t,e)=>Math.max(t,e.y+e.in||0)),0),u=0;return l>=f?(i.forEach((t=>{l=d(t,l),l=Math.max(l+t.out,c(t,l))})),s.forEach((t=>{f=d(t,f),f=Math.max(f+t.in,c(t,f))}))):(s.forEach((t=>{f=d(t,f),f=Math.max(f+t.in,c(t,f))})),i.forEach((t=>{l=d(t,l),l=Math.max(l+t.out,c(t,l))}))),a.forEach((e=>{let o=t.filter((t=>t.x===e.x&&r(t.y))).reduce(((t,e)=>Math.max(t,e.y+Math.max(e.in,e.out))),0);o=d(e,o),o=Math.max(o+e.in,h(e,o)),o=Math.max(o+e.out,c(e,o)),u=Math.max(u,o)})),Math.max(l,f,u)}(t,e);return Math.max(n,i,s)}function u(t,e,o,s){const a=[...t.values()],l=function(t,e){const o=new Set(e.map((t=>t.to))),i=new Set(e.map((t=>t.from))),s=new Set([...t.keys()]);let a=0;for(;s.size;){const i=n([...s],o);for(const e of i){const o=t.get(e);r(o.x)||(o.x=a),s.delete(e)}s.size&&(o.clear(),e.filter((t=>s.has(t.from))).forEach((t=>o.add(t.to))),a++)}return[...t.keys()].filter((t=>!i.has(t))).forEach((e=>{const o=t.get(e);o.column||(o.x=a)})),[...t.values()].reduce(((t,e)=>Math.max(t,e.x)),0)}(t,e),h=o?function(t,e){let o=0,r=0;for(let n=0;n<=e;n++){let e=r;const i=t.filter((t=>t.x===n)).sort(((t,e)=>t.priority-e.priority));r=i.length&&i[0].to.filter((t=>t.node.x>n+1)).reduce(((t,e)=>t+e.flow),0)||0;for(const t of i)t.y=e,e+=Math.max(t.out,t.in);o=Math.max(e,o)}return o}(a,l):f(a,l),c=function(t,e){let o=1,r=0,n=0,s=0;const a=[];t.sort(i);for(const i of t){if(i.y){if(0===i.x)a.push(i.y);else{for(r!==i.x&&(r=i.x,n=0),o=n+1;o<a.length&&!(a[o]>i.y);o++);n=o}i.y+=o*e,o++}s=Math.max(s,i.y+Math.max(i.in,i.out))}return s}(a,.03*h);return function(t,e){t.forEach((t=>{const o=Math[e](t.in||t.out,t.out||t.in),r=o<t.in,n=o<t.out;let i=0,s=t.from.length;t.from.sort(((t,e)=>t.node.y+t.node.out/2-(e.node.y+e.node.out/2))).forEach(((t,e)=>{r?t.addY=e*(o-t.flow)/(s-1):(t.addY=i,i+=t.flow)})),i=0,s=t.to.length,t.to.sort(((t,e)=>t.node.y+t.node.in/2-(e.node.y+e.node.in/2))).forEach(((t,e)=>{n?t.addY=e*(o-t.flow)/(s-1):(t.addY=i,i+=t.flow)}))}))}(a,s),{maxX:l,maxY:c}}function y(t,e,o){for(const r of t)if(r.key===e&&r.index===o)return r.addY;return 0}class x extends t.DatasetController{parseObjectData(t,r,n,i){const{from:s="from",to:a="to",flow:l="flow"}=this.options.parsing,h=r.map((({[s]:t,[a]:e,[l]:o})=>({from:t,to:e,flow:o}))),{xScale:c,yScale:d}=t,f=[],x=this._nodes=function(t){const e=new Map;for(let o=0;o<t.length;o++){const{from:r,to:n,flow:i}=t[o];if(e.has(r)){const t=e.get(r);t.out+=i,t.to.push({key:n,flow:i,index:o})}else e.set(r,{key:r,in:0,out:i,from:[],to:[{key:n,flow:i,index:o}]});if(e.has(n)){const t=e.get(n);t.in+=i,t.from.push({key:r,flow:i,index:o})}else e.set(n,{key:n,in:i,out:0,from:[{key:r,flow:i,index:o}],to:[]})}const o=(t,e)=>e.flow-t.flow;return[...e.values()].forEach((t=>{t.from=t.from.sort(o),t.from.forEach((t=>{t.node=e.get(t.key)})),t.to=t.to.sort(o),t.to.forEach((t=>{t.node=e.get(t.key)}))})),e}(h),{column:g,priority:p,size:m}=this.getDataset();if(p)for(const t of x.values())t.key in p&&(t.priority=p[t.key]);if(g)for(const t of x.values())t.key in g&&(t.column=!0,t.x=g[t.key]);const{maxX:b,maxY:M}=u(x,h,!!p,o(m));this._maxX=b,this._maxY=M;for(let t=0,o=h.length;t<o;++t){const o=h[t],r=x.get(o.from),n=x.get(o.to),i=r.y+y(r.to,o.to,t),s=n.y+y(n.from,o.from,t);f.push({x:c.parse(r.x,t),y:d.parse(i,t),_custom:{from:r,to:n,x:c.parse(n.x,t),y:d.parse(s,t),height:d.parse(o.flow,t),nodeWidth:e.valueOrDefault(this.getDataset().nodeWidth,10)}})}return f.slice(n,n+i)}getMinMax(t){return{min:0,max:t===this._cachedMeta.xScale?this._maxX:this._maxY}}update(t){const{data:e}=this._cachedMeta;this.chart.config.options.padding={},this.updateElements(e,0,e.length,t)}updateElements(t,o,r,n){const{xScale:i,yScale:s}=this._cachedMeta,a=this.resolveDataElementOptions(o,n),l=this.getSharedOptions(n,t[o],a),h=this.getDataset(),c=e.valueOrDefault(h.borderWidth,1)/2+.5,d=e.valueOrDefault(h.nodeWidth,10);for(let e=o;e<o+r;e++){const o=this.getParsed(e),r=o._custom,a=s.getPixelForValue(o.y);console.log({parsed:o});const l=o._custom.from.key,h=0===o._custom.from.from.length,f=this.nodeLabels[l],u=this.labelPositions[l],y=o._custom.to.key,x=0===o._custom.to.to.length,g=this.nodeLabels[y],p=this.labelPositions[y];let m=0,b=0;f&&"left"===u&&h&&(m=this._ctx.measureText(f).width+d/2+c),g&&"right"===p&&x&&(b=-this._ctx.measureText(g).width-d/2-c),this.updateElement(t[e],e,{x:i.getPixelForValue(o.x)+d+c+m,y:a,x2:i.getPixelForValue(r.x)-c+b,y2:s.getPixelForValue(r.y),from:r.from,to:r.to,progress:"reset"===n?0:1,height:Math.abs(s.getPixelForValue(o.y+r.height)-a),options:this.resolveDataElementOptions(e,n)},n)}this.updateSharedOptions(l,n)}mapNodeSettingBySettingKey(t){const e=this.getDataset().nodeSettings;if(e){return Object.entries(e).reduce(((e,[o,r])=>(e[o]=r[t]||null,e)),{})}return{}}get nodePatterns(){return this.mapNodeSettingBySettingKey("pattern")}get nodeLabels(){return this.mapNodeSettingBySettingKey("label")}get nodeColors(){return this.mapNodeSettingBySettingKey("color")}get labelPositions(){return this.mapNodeSettingBySettingKey("labelPosition")}_drawLabels(){const t=this._ctx,r=this._nodes||new Map,n=this.getDataset(),i=o(n.size),s=e.valueOrDefault(n.borderWidth,1),a=e.valueOrDefault(n.nodeWidth,10),l=this.nodeLabels,{xScale:h,yScale:c}=this._cachedMeta;t.save();const d=this.chart.chartArea;for(const o of r.values()){const r=h.getPixelForValue(o.x),f=c.getPixelForValue(o.y),u=Math[i](o.in||o.out,o.out||o.in),y=Math.abs(c.getPixelForValue(o.y+u)-f),x=l&&l[o.key]||o.key;let g=r,p=f;t.fillStyle=e.color(this.nodeColors[o.key]).darken(.4).hexString()||n.color||"black",t.textBaseline="middle";switch(this.labelPositions[o.key]){case"left":0===o.from.length?t.textAlign="left":(t.textAlign="right",g-=s+4);break;case"right":0===o.to.length?(t.textAlign="right",g+=a+s):(t.textAlign="left",g+=a+s+4);break;case"top":t.textAlign="center",g+=a/2,p-=y/2+s+8;break;default:r<d.width/2?(t.textAlign="left",g+=a+s+4):(t.textAlign="right",g-=s+4)}this._drawLabel(x,p,y,t,g)}t.restore()}_drawLabel(t,o,r,n,i){const s=e.toFont(this.options.font,this.chart.options.font),a=e.isNullOrUndef(t)?[]:function(t){const o=[],r=e.isArray(t)?t:e.isNullOrUndef(t)?[]:[t];for(;r.length;){const t=r.pop();"string"==typeof t?o.unshift.apply(o,t.split("\n")):Array.isArray(t)?r.push.apply(r,t):e.isNullOrUndef(r)||o.unshift(""+t)}return o}(t),l=a.length,h=o+r/2,c=s.lineHeight,d=e.valueOrDefault(this.options.padding,c/2);if(n.font=s.string,l>1){const t=h-c*l/2+d;for(let e=0;e<l;e++)n.fillText(a[e],i,t+e*c)}else n.fillText(t,i,h)}_drawNodes(){const t=this._ctx,r=this._nodes||new Map,n=this.getDataset(),i=o(n.size),{xScale:s,yScale:a}=this._cachedMeta,l=e.valueOrDefault(n.borderWidth,1),h=e.valueOrDefault(n.nodeWidth,10);t.save(),t.strokeStyle=n.borderColor||"black",t.lineWidth=l;for(const e of r.values()){const o=s.getPixelForValue(e.x),r=a.getPixelForValue(e.y),n=Math[i](e.in||e.out,e.out||e.in),c=Math.abs(a.getPixelForValue(e.y+n)-r),d=this.nodePatterns[e.key],f=this.nodeLabels[e.key],u=this.labelPositions[e.key],y=f?t.measureText(f).width:0;let x=o;f&&"left"===u&&0===e.from.length&&(x+=y+h/4+l),f&&"right"===u&&0===e.to.length&&(x-=y+h/8+l),t.beginPath(),t.fillStyle=d||e.color,l&&t.roundRect(x,r,h,c,20),t.roundRect(x,r,h,c,20),t.fill(),t.stroke()}t.restore()}draw(){const t=this._ctx,e=this.getMeta().data||[],o=[];for(let t=0,r=e.length;t<r;++t){const r=e[t];r.from.color=this.nodeColors[r.from.key]||r.options.colorFrom,r.to.color=this.nodeColors[r.to.key]||r.options.colorTo,r.active&&o.push(r)}for(const t of o)t.from.color=this.nodeColors[t.from.key]||t.options.colorFrom,t.to.color=this.nodeColors[t.to.key]||t.options.colorTo;for(let o=0,r=e.length;o<r;++o)e[o].draw(t);this._drawNodes(),this._drawLabels()}}x.id="sankey",x.defaults={dataElementType:"flow",animations:{numbers:{type:"number",properties:["x","y","x2","y2","height"]},progress:{easing:"linear",duration:t=>"data"===t.type?200*(t.parsed._custom.x-t.parsed.x):void 0,delay:t=>"data"===t.type?500*t.parsed.x+20*t.dataIndex:void 0},colors:{type:"color",properties:["colorFrom","colorTo"]}},transitions:{hide:{animations:{colors:{type:"color",properties:["colorFrom","colorTo"],to:"transparent"}}},show:{animations:{colors:{type:"color",properties:["colorFrom","colorTo"],from:"transparent"}}}}},x.overrides={interaction:{mode:"nearest",intersect:!0},datasets:{clip:!1,parsing:!0},plugins:{tooltip:{callbacks:{title:()=>"",label(t){const e=t.dataset.data[t.dataIndex];return e.from+" -> "+e.to+": "+e.flow}}},legend:{display:!1}},scales:{x:{type:"linear",bounds:"data",display:!1,min:0,offset:!1},y:{type:"linear",bounds:"data",display:!1,min:0,reverse:!0,offset:!1}},layout:{padding:{top:3,left:3,bottom:3}}};const g=(t,e,o,r)=>t<o?{cp1:{x:t+(o-t)/3*2,y:e},cp2:{x:t+(o-t)/3,y:r}}:{cp1:{x:t-(t-o)/3,y:0},cp2:{x:o+(t-o)/3,y:0}},p=(t,e,o)=>({x:t.x+o*(e.x-t.x),y:t.y+o*(e.y-t.y)});class m extends t.Element{constructor(t){super(),this.options=void 0,this.x=void 0,this.y=void 0,this.x2=void 0,this.y2=void 0,this.height=void 0,t&&Object.assign(this,t)}draw(t){const o=this,{x:r,x2:n,y:i,y2:s,height:a,progress:l}=o,h=o.$context.parsed._custom.nodeWidth/2,c=r-h,d=n+h,{cp1:f,cp2:u}=g(c,i,d,s);0!==l&&(t.save(),l<1&&(t.beginPath(),t.rect(c,Math.min(i,s),(d-c)*l+1,Math.abs(s-i)+a+1),t.clip()),function(t,o){const{x:r,x2:n,options:i,from:s,to:a}=o;let l;"from"===i.colorMode?l=e.color(s.color).alpha(.2).rgbString():"to"===i.colorMode?l=e.color(a.color).alpha(.2).rgbString():(l=t.createLinearGradient(r,0,n,0),l.addColorStop(0,e.color(s.color).alpha(.2).rgbString()),l.addColorStop(1,e.color(a.color).alpha(.2).rgbString())),t.fillStyle=l,t.strokeStyle=l,t.lineWidth=.5}(t,o),t.beginPath(),t.moveTo(c,i),t.bezierCurveTo(f.x,f.y,u.x,u.y,d,s),t.lineTo(d,s+a),t.bezierCurveTo(u.x,u.y+a,f.x,f.y+a,c,i+a),t.lineTo(c,i),t.stroke(),t.closePath(),t.fill(),t.restore())}inRange(t,e,o){const{x:r,y:n,x2:i,y2:s,height:a}=this.getProps(["x","y","x2","y2","height"],o);if(t<r||t>i)return!1;const{cp1:l,cp2:h}=g(r,n,i,s),c=(t-r)/(i-r),d={x:i,y:s},f=p({x:r,y:n},l,c),u=p(l,h,c),y=p(h,d,c),x=p(f,u,c),m=p(u,y,c),b=p(x,m,c).y;return e>=b&&e<=b+a}inXRange(t,e){const{x:o,x2:r}=this.getProps(["x","x2"],e);return t>=o&&t<=r}inYRange(t,e){const{y:o,y2:r,height:n}=this.getProps(["y","y2","height"],e),i=Math.min(o,r),s=Math.max(o,r)+n;return t>=i&&t<=s}getCenterPoint(t){const{x:e,y:o,x2:r,y2:n,height:i}=this.getProps(["x","y","x2","y2","height"],t);return{x:(e+r)/2,y:(o+n+i)/2}}tooltipPosition(t){return this.getCenterPoint(t)}getRange(t){return"x"===t?this.width/2:this.height/2}}m.id="flow",m.defaults={colorFrom:"red",colorTo:"green",colorMode:"gradient"},t.Chart.register(x,m)}));
